use crate::ast::{
    Constant as C,
    Expression as E,
    Operation as O,
    Statement as S,
};

grammar;

pub Const: C = {
    r"'[^'\\]'" => C::Character(<>.chars().nth(1).unwrap()),
    r"'\\['\\rnt0]'" => C::Character({
        match <>.chars().nth(2) {
            Some('\'') => '\'',
            Some('\\') => '\\',
            Some('r')  => '\r',
            Some('n')  => '\n',
            Some('t')  => '\t',
            Some('0')  => '\0',
            _ => unimplemented!("Unknown escaped character!"),
        }
    }),
    r#""""# => C::String("".to_string()),
    // wrapped in double-quotes
    // any char except double-quotes,
    // or escaped double-quote, repeating.
    // the last character of the string
    // must not be a backslash
    r#""([^"]|([\\]["]))*([^\\]|\\\\)""# => C::String((<>)[1..<>.len()-1].to_string()),
    r"[+-]?\d+" => C::Integer(<>.parse().unwrap()),
    r"[+-]?\d+\.\d+" => C::Float(<>.parse().unwrap()),
    r"IGAZ|igaz" => C::Boolean(true),
    r"HAMIS|hamis" => C::Boolean(false),
};

/// An expression in atomic
/// if it consists of only one part
AtomicExpr: E = {
    Const => E::Const(<>),
    WrappedExpr => <>,
};

// A wrapper converts any expression into an atom
WrappedExpr: E = {
    "(" <Expr> ")" => E::Op(O::Parentheses(<>.into())),
    "|" <Expr> "|" => E::Op(O::Abs(<>.into())),
    <x:Const> "[" <idx:Expr> "]" => E::Op(O::ItemAt(E::Const(x.into()).boxed(), idx.into())),
    <x:Const> "[" <i1:Expr> ":" <i2:Expr> "]" => E::Op(O::Slice(
        E::Const(x.into()).boxed(),
        i1.into(),
        i2.into()
    )),
};

/// An expression in unary
/// if it consists of exactly two parts:
/// an operation as prefix and an atomic expression
AtomicOrUnary: E = { AtomicExpr, UnaryExpr };

UnaryExpr: E = { UnaryOp => E::Op(<>) };
UnaryOp: O = {
    // The recommended format is to leave a whitespace after the operation,
    // but the whitespace can be left, if the expression is wrapped.
    r"(NEM|nem)\s"          <AtomicOrUnary> => O::Not(<>.into()),
    r"(NEM|nem)"            <WrappedExpr>   => O::Not(<>.into()),
    "-"                     <AtomicOrUnary> => O::Neg(<>.into()),
    r"(RND|rnd)\s"          <AtomicOrUnary> => O::Rnd(<>.into()),
    r"(RND|rnd)"            <WrappedExpr>   => O::Rnd(<>.into()),
    r"(SIN|sin)\s"          <AtomicOrUnary> => O::Sin(<>.into()),
    r"(SIN|sin)"            <WrappedExpr>   => O::Sin(<>.into()),
    r"(COS|cos)\s"          <AtomicOrUnary> => O::Cos(<>.into()),
    r"(COS|cos)"            <WrappedExpr>   => O::Cos(<>.into()),
    r"(TAN|tan)\s"          <AtomicOrUnary> => O::Tan(<>.into()),
    r"(TAN|tan)"            <WrappedExpr>   => O::Tan(<>.into()),
    r"(ARCSIN|arcsin)\s"    <AtomicOrUnary> => O::Arcsin(<>.into()),
    r"(ARCSIN|arcsin)"      <WrappedExpr>   => O::Arcsin(<>.into()),
    r"(ARCCOS|arccos)\s"    <AtomicOrUnary> => O::Arccos(<>.into()),
    r"(ARCCOS|arccos)"      <WrappedExpr>   => O::Arccos(<>.into()),
    r"(LOG|log)\s"          <AtomicOrUnary> => O::Log(<>.into()),
    r"(LOG|log)"            <WrappedExpr>   => O::Log(<>.into()),
    r"(EXP|exp)\s"          <AtomicOrUnary> => O::Exp(<>.into()),
    r"(EXP|exp)"            <WrappedExpr>   => O::Exp(<>.into()),
    r"(VAL[OÓ]S|val[oó]s)\s"<AtomicOrUnary> => O::ToFloat(<>.into()),
    r"(VAL[OÓ]S|val[oó]s)"  <WrappedExpr>   => O::ToFloat(<>.into()),
    r"(EGESZ|egesz)\s"      <AtomicOrUnary> => O::Floor(<>.into()),
    r"(EGESZ|egesz)"        <WrappedExpr>   => O::Floor(<>.into()),
    r"(KEREK|kerek)\s"      <AtomicOrUnary> => O::Round(<>.into()),
    r"(KEREK|kerek)"        <WrappedExpr>   => O::Round(<>.into()),
    r"(NAGY|nagy)\s"        <AtomicOrUnary> => O::ToUpper(<>.into()),
    r"(NAGY|nagy)"          <WrappedExpr>   => O::ToUpper(<>.into()),
    r"(KIS|kis)\s"          <AtomicOrUnary> => O::ToLower(<>.into()),
    r"(KIS|kis)"            <WrappedExpr>   => O::ToLower(<>.into()),
    r"(BETU|betu)\s"        <AtomicOrUnary> => O::IsWordChar(<>.into()),
    r"(BETU|betu)"          <WrappedExpr>   => O::IsWordChar(<>.into()),
    r"(SZAM|szam)\s"        <AtomicOrUnary> => O::IsDigit(<>.into()),
    r"(SZAM|szam)"          <WrappedExpr>   => O::IsDigit(<>.into()),
};

// ######## BINARY OPERATIONS ########
//
// The order of execution is determinated by the operations
// Some operations are "stronger" than others.
// The parser will go from the lowest tier to the highest tier.
// An will _fall back_ to the strongest tier.

// In the context of binary operations,
// unary operations can be considered atomic.
Tier0 = { AtomicOrUnary };

Tier1: E = {
    <l:Tier1> "^" <r:Tier0> => E::Op(O::Pow   (l.boxed(), r.boxed())),
    <l:Tier1> "@" <r:Tier0> => E::Op(O::Search(l.boxed(), r.boxed())),
    Tier0,
};

Tier2: E = {
    <l:Tier2> "*" <r:Tier1>         => E::Op(O::Mul   (l.boxed(), r.boxed())),
    <l:Tier2> "/" <r:Tier1>         => E::Op(O::Div   (l.boxed(), r.boxed())),
    <l:Tier2> r"DIV|div" <r:Tier1>  => E::Op(O::DivInt(l.boxed(), r.boxed())),
    <l:Tier2> r"MOD|mod" <r:Tier1>  => E::Op(O::Mod   (l.boxed(), r.boxed())),
    Tier1,
};

Tier3: E = {
    <l:Tier3> "+" <r:Tier2> => E::Op(O::Add(l.boxed(), r.boxed())),
    <l:Tier3> "-" <r:Tier2> => E::Op(O::Sub(l.boxed(), r.boxed())),
    Tier2,
};


Tier4: E = {
    // FIXME space around =
    <l:Tier4> " =" <r:Tier3> => E::Op(O::Eq(l.boxed(), r.boxed())),
    <l:Tier4> "/=" <r:Tier3> => E::Op(O::Ne(l.boxed(), r.boxed())),
    <l:Tier4> "< " <r:Tier3> => E::Op(O::Lt(l.boxed(), r.boxed())),
    <l:Tier4> "<=" <r:Tier3> => E::Op(O::Le(l.boxed(), r.boxed())),
    <l:Tier4> "> " <r:Tier3> => E::Op(O::Gt(l.boxed(), r.boxed())),
    <l:Tier4> ">=" <r:Tier3> => E::Op(O::Ge(l.boxed(), r.boxed())),
    Tier3,
};

Tier5: E = {
    <l:Tier5> r"[EÉ]S|[eé]s" <r:Tier4> => E::Op(O::And(l.boxed(), r.boxed())),
    <l:Tier5> r"VAGY|vagy"   <r:Tier4> => E::Op(O::Or(l.boxed(), r.boxed())),
    Tier4,
};

// The weakest operation will be on the bottom of the stack.
pub Expr: E = Tier5;

pub Statement: S = {
    r"(KI|ki):" <Expr> => S::Cout(<>),
}

pub Input: E = {
    Expr
};
