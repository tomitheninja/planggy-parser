use crate::ast::{
    Constant as C,
    Expression as E,
    Operation as O,
};

grammar;

Const: C = {
    r"'[^'\\]'" => C::Character(<>.chars().nth(1).unwrap()),
    r"'\\.'" => C::Character({
        match <>.chars().nth(2) {
            Some('\'') => '\'',
            Some('\\') => '\\',
            Some('r')  => '\r',
            Some('n')  => '\n',
            Some('t')  => '\t',
            Some('0')  => '\0',
            _ => unimplemented!("Unknown escaped character!"),
        }
    }),
    r#""""# => C::String("".to_string()),
    // wrapped in double-quotes
    // any char except double-quotes,
    // or escaped double-quote, repeating.
    // the last character of the string
    // must not be a backslash
    r#""([^"]|([\\]["]))*([^\\]|\\\\)""# => C::String((<>)[1..<>.len()-1].to_string()),
    r"[+-]?\d+" => C::Integer(<>.parse().unwrap()),
    r"[+-]?\d+\.\d+" => C::Float(<>.parse().unwrap()),
    r"IGAZ|igaz" => C::Boolean(true),
    r"HAMIS|hamis" => C::Boolean(false),
};

/// An expression in atomic
/// if it consists of only part
AtomicExpr: E = {
    Const => E::Const(<>),
    WrappedExpr => <>,
};

WrappedExpr: E = {
    "(" <Expr> ")" => E::Op(O::Parentheses(Box::new(<>))),
}

AtomicOrUnary: E = { AtomicExpr, UnaryExpr };

/// An expression in unary
/// if it consists of exactly two parts:
/// an operation as prefix and an atomic expression
UnaryExpr: E = {
    // The recommended format is to leave a whitespace after the operation,
    // but the whitespace can be left, if the expression is wrapped.
    r"(NEM|nem)\s" <AtomicOrUnary> => E::Op(O::Not(Box::new(<>))),
    r"(NEM|nem)" <WrappedExpr> => E::Op(O::Not(Box::new(<>))),
    "-" <AtomicOrUnary> => E::Op(O::Neg(Box::new(<>))),
}

pub Expr: E = {
    AtomicExpr,
    UnaryExpr,
};

pub Input: E = {
    Expr
};
